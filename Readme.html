<html>
	<head>
		<style>
			html {
			background-color: #000207;
			color: white;
			font-family: sans-serif;
			}
			
			table, th, td {
			border: 1px solid white;
			border-collapse: collapse;
			}
			
			span.NoLineBreak {
				white-space: nowrap;
			}
			
			abbr{cursor: help;}
			img.img-hor {
				-moz-transform: scaleX(-1);
				-o-transform: scaleX(-1);
				-webkit-transform: scaleX(-1);
				transform: scaleX(-1);
				filter: FlipH;
				-ms-filter: "FlipH";
			}
		</style>
	</head>
<body>
<center><h1>Custom scroll limits</h1></center>
<h2>Introduction</h2>
<p>This ASM package enables you to set custom boundaries of your level.</p>

<p>Also comes with a feature to have Megaman/Celeste/Zelda-styled scroll areas where the camera will not cross between areas unless you go to that area.</p>

<p>Normally, you would think this is redundant because there exist other codes that stops the screen scrolling at a certain XY position, say one
found in the <a href="https://www.smwcentral.net/?p=viewthread&t=62286">ASM library</a>, however this ASM package offers more flexibility, and that
you can have &ldquo;multiple scroll stops&rdquo; without duplicate code</p>
<h2>Note before use</h2>
<ul>
	<li>This patch obviously will hijack scrolling related codes (<kbd>$00F73C</kbd> (horizontal level limits for left and right borders), <kbd>$00F893</kbd>
	(horizontal and vertical limits for top and bottom borders)). If you wish to have other scrolling-related patches such as my <a href="https://www.smwcentral.net/?p=section&a=details&id=26861">Center scroll patch</a>
	or <a href="https://www.smwcentral.net/?p=section&a=details&id=17737">Vertical Camera Panning</a>. In these cases, you'll need to merge the ASM files (more specifically, not to use SMW's default scroll limits but
	use this custom scroll limits patch's RAM that controls the limits)</li>
	<li>SMW's horizontal scrolling is instant-- that it simply takes Mario's X position, take various calculations handled at <kbd>$00F73C</kbd> (which also handles the left and right limits), unlike vertical scrolling,
	which that is handled at <kbd>$00F88F</kbd>, horizontal scrolling <b>instantly</b> sets the screen X position within the level rather than gradually incrementing/decrementing it. So these situations should be avoided that causes
	layer 1 graphic glitches due to not giving it frames to load the columns of 16x16 tiles:
		<ul>
			<li>Teleporting the player, as in taking the player's X position (<kbd>$94</kbd>), add or subtract by some large number that results the player being &ldquo;teleported&rdquo; in long distances.</li>
			<li>Have horizontal scrolling disabled (<kbd>$1411</kbd> set to $00), then enable horizontal scrolling while the player is outside the static camera region. This will cause the camera to jump to be centered
			with the player</li>
		</ul>
	
	</li>
	<li>RAM address <kbd>$13F2</kbd> is no longer cleared by <kbd>$00F8A7</kbd>.</li>
	<li>Anytime you want to trigger a &ldquo;<abbr title="The effect you see in Megaman games, areas separated by scroll limits that the screen will not go past unless the player triggers something like opening a door or touching the edge of an area">flip screen</abbr>&rdquo;
	effect, I <b>highly</b> recommend setting <kbd>$1411</kbd> and <kbd>$1412</kbd> to zero (disable horizontal and vertical scrolling). Even though uberasm tool already
	STZs it, if you don't disable horizontal scrolling and your code is executed, then runs <kbd>$00F70D</kbd> or <kbd>$00F75C</kbd>, before executing uberasm tool's gamemode 14, screen-jumping (screen changes position instantly
	and result graphical glitches) can still occur</li>
	<li>Setting <kbd>$1411</kbd> and <kbd>$1412</kbd> only disables the default scrolling (the behavior of the screen to follow the player) as well as the scrolling limit not to go left past the screen $00 or go right past the last
	screen. Autoscroll generators have done this.</li>
</ul>
<h2>What you need</h2>
<ul>
	<li><a href="https://www.smwcentral.net/?p=section&a=details&id=13675">Sprite scroll fix</a>: The system to check which scroll direction sprites should be able to spawn (<kbd>$55</kbd>/<kbd>$56</kbd>) is flawed, that it
	check which side the player is located relative to the &ldquo;static camera region&rdquo; (<kbd>$142A</kbd>), rather than the actual scrolling of the screen.</li>
	<li><a href="https://www.smwcentral.net/?p=section&a=details&id=14978">Disable Screen Barrier via RAM</a>: Useful if you want such triggers that would trigger the flip-screen effect by touching the very edges of the screen, and also
	prevent potential deaths caused by being at those edges of the screen.</li>
	<li>ASM knowledge, if you are using other screen scrolling-related patches that modifies how the player scrolls the screen, such as my <a href="https://www.smwcentral.net/?p=section&a=details&id=26861">center scroll</a> patch, which is a really high chance
	of conflicts or simply not executing at all (like a patch that JMLs to skip the hijacks that <kbd>ScrollLimitsPatch.asm</kbd> wrote on):
		<ul>
			<li><a href="https://www.smwcentral.net/?p=section&a=details&id=20949">ASM workshop</a></li>
			<li><a href="https://www.smwcentral.net/?p=section&a=details&id=14268">Ersanio's ASM tutorial</a></li>
		</ul>
	</li>
</ul>
<h2>Interesting facts</h2>
<ul>
	<li>When horizontal and/or vertical scrolling are disabled (<kbd>$1411</kbd> and/or <kbd>$1412</kbd>), the boundaries (left or right for horizontal, top and bottom for vertical) are no longer running (it will not set the XY coordinate of
	the screen to place it back in bounds).</li>
</ul>
<h2>Installation</h2>
	<ol>
		<li>Defines</li>
		<ol>
			<li>Open <kbd>SMW-Scroll-limits/ScrollLimitsDefines/Defines.asm</kbd>, and make any necessary changes on it. There is a very high chance you'll need to do this if you have other ASM resources that uses freeram as well, as they
			tend to &ldquo;overlap&rdquo; with the default RAMs the patch provided here uses.</li>
		</ol>
		<li>Patches</li>
		<ol>
			<li>Before you patch <kbd>ScrollLimitsPatch.asm</kbd> or other patches related to scrolling, open <kbd>ScrollLimitsPatch.asm</kbd> AND the other patches (specifically if they hijack scrolling-related code) and see the
			<kbd>org $xxxxxx</kbd> would conflict. If they do, you'll need to merge them and potentially need to learn a little bit of ASM.<br><br>
			
			<kbd>ScrollLimitsPatch.asm</kbd> just modifies the behavior how scrolling limits work. If you say, install my &ldquo;Center Scroll&rdquo; patch, for example, edit the center scroll patch's scroll limits so that it first checks
			the RAM defined by <kbd>!Freeram_ScrollLimitsFlag</kbd>, and if it is nonzero, then it should do something similar how the patch provided here works (which means you'll need to learn about ASM).</li>
		</ol>
		<li>Uberasm tool (installs the flip screen effect)</li>
		<ol>
			<li>In <kbd>SMW-Scroll-limits/UberasmTool/</kbd>, place the files in their appropriate spots in uberasm tool's files. They are conveniently named.</li>
			<li>Run the tool</li>
		</ol>
	</ol>
<h2>How to use them in a level</h2>
	<p>With these installed (properly) you can now set your own borders. Keep these information in mind:</p>
	<ul>
		<li><font color="grey">Grey</font> means outside the level boundaries</li>
		<li><font color="blue">blue</font> means inside the level boundaries</li>
		<li><font color="cyan">cyan</font> means the game screen</li>
		<li><font color="#800000">red</font> means the boundaries specified by the RAM the patch uses</li>
		<li><font color="orange">orange</font> means the actual scrolling stopping position for the bottom and right borders</li>
	</ul>
	<p>Scroll stopping positions info</p>
	<ul>
		<li>Origin positions:<br>
		<img src="readme_files/LevelAndGameScreen.png"><br>
		Almost everything have their origin point on their top-left corner.</li>
		<li>How the right and bottom borders are placed, relative to the origin position of the scroll limits box:<br>
		<img src="readme_files/ScrollLimitsBox.png"></li>
		<li>Where the screen will stop at relative to the border:<br>
		<img src="readme_files/LeftAndTop.png"><br>
		Pretty obvious, but for bottom and right borders, they take the screen's origin position to limit instead of the right and bottom edge of the screen:<br>
		<img src="readme_files/RightAndBottom.png"><br>
		</li>
	</ul>
<h2>Data table format</h2>
	<ul>
		<li>
<table><tr><td><pre>main:
	;This prevents the layers from snapping upon entering the level after a fade-in
		LDA.b #ScreenBoundsXPositions : STA $00
		LDA.b #ScreenBoundsXPositions&gt;&gt;8 : STA $01
		LDA.b #ScreenBoundsXPositions&gt;&gt;16 : STA $02
		LDA.b #ScreenBoundsYPositions : STA $03
		LDA.b #ScreenBoundsYPositions&gt;&gt;8 : STA $04
		LDA.b #ScreenBoundsYPositions&gt;&gt;16 : STA $05
		LDA.b #ScreenBoundsWidths : STA $06
		LDA.b #ScreenBoundsWidths&gt;&gt;8 : STA $07
		LDA.b #ScreenBoundsWidths&gt;&gt;16 : STA $08
		LDA.b #ScreenBoundsHeights : STA $09
		LDA.b #ScreenBoundsHeights&gt;&gt;8 : STA $0A
		LDA.b #ScreenBoundsHeights&gt;&gt;16 : STA $0B
		LDA.b #(ScreenBoundsYPositions-ScreenBoundsXPositions)-2 : STA $0C : STZ $0D
		JSL LibraryScrollLimits_SetupBorders
		LDA #$03 : STA $0C
		JSL LibraryScrollLimits_ControlBorders
		RTL
;Scroll limit box attributes, each index is each screen area.
;Make sure the number of values all matches!
;
;Easy formula to calculate where the screen should be at:
; LM_CoordinateOfTopLeft_TopOrLeftmost_Screen*16
; Where:
;  -LM_CoordinateOfTopLeft_TopOrLeftmost_Screen means the top left of the screen at the leftmost
;   position possible, in block-coordinates (not pixel), either X or Y position
;Top-left positions
	ScreenBoundsXPositions:
		dw $0000*16		;&gt;$00
		dw $0018*16		;&gt;$01
		dw $0028*16		;&gt;$02
		dw $0028*16		;&gt;$03
		dw $003C*16		;&gt;$04
		dw $004C*16		;&gt;$05
		dw $005C*16		;&gt;$06
		dw $005C*16		;&gt;$07
		dw $007C*16		;&gt;$08
		dw $009D*16		;&gt;$09
	ScreenBoundsYPositions:
		dw $0000*16		;&gt;$00
		dw $0015*16		;&gt;$01
		dw $000B*16		;&gt;$02
		dw $001C*16		;&gt;$03
		dw $0000*16		;&gt;$04
		dw $000C*16		;&gt;$05
		dw $000C*16		;&gt;$06
		dw $001A*16		;&gt;$07
		dw $0000*16		;&gt;$08
		dw $0000*16		;&gt;$09
;Widths and heights. Easy formula if you want positions for both the top-lefts and bottom-rights.
; (LM_CoordinateOfTopLeft_BottomOrRightmost_Screen-LM_CoordinateOfTopLeft_TopOrLeftmost_Screen)*16
; Where:
;  -LM_CoordinateOfTopLeft_TopOrLeftmost_Screen means the top left of the screen at the leftmost
;   position possible, in block-coordinates (not pixel), either X or Y position
;  -LM_CoordinateOfTopLeft_BottomOrRightmost_Screen means the top-left of the screen at the rightmost
;   position possible, in block-coordinates (not pixel), either X or Y position
;
	ScreenBoundsWidths:
		dw ($0008-$0000)*16	;&gt;$00
		dw ($0018-$0018)*16	;&gt;$01
		dw ($0028-$0028)*16	;&gt;$02
		dw ($0046-$0028)*16	;&gt;$03
		dw ($003C-$003C)*16	;&gt;$04
		dw ($004C-$004C)*16	;&gt;$05
		dw ($006C-$005C)*16	;&gt;$06
		dw ($0063-$005C)*16	;&gt;$07
		dw ($008D-$007C)*16	;&gt;$08
		dw ($00AD-$009D)*16	;&gt;$09
	ScreenBoundsHeights:
		dw ($000C-$0000)*16	;&gt;$00
		dw ($0015-$0015)*16	;&gt;$01
		dw ($000B-$000B)*16	;&gt;$02
		dw ($001C-$001C)*16	;&gt;$03
		dw ($000E-$0000)*16	;&gt;$04
		dw ($000C-$000C)*16	;&gt;$05
		dw ($000C-$000C)*16	;&gt;$06
		dw ($001A-$001A)*16	;&gt;$07
		dw ($001B-$0000)*16	;&gt;$08
		dw ($001B-$0000)*16	;&gt;$09</pre></td></tr></table><br>
		The tables, labeled <kbd>ScreenBoundsXPositions</kbd>, <kbd>ScreenBoundsYPositions</kbd>, <kbd>ScreenBoundsWidths</kbd>, and <kbd>ScreenBoundsHeights</kbd>, is what we need to focus on.
		Keep in mind that each same nth item in the table are associated with each other, meaning that the first item in the tables are used together for zone 0, second item in tables for zone 1, and so on,
		they do not use other items within them (like zone 0 uses first item in <kbd>ScreenBoundsXPositions</kbd>, second item in <kbd>ScreenBoundsYPositions</kbd>, it doesn't work like that)</li>
	</ul>
	
<h3>Instructions to use in level</h3>
	<ol>
		<li>After creating a level, make LM display the &ldquo;Game View Screen&rdquo;, this is found in the <kbd>View</kbd> on the menu bar or pressing F3. Hold ALT+F3 to drag it around and place them
		at the top-left area where you want to place your top and leftmost limit, then hover your mouse on a block where that top-left area of the screen. Do the same thing again but place the game view
		screen at the bottom-rightmost area (while still using the top-left of the game view screen), to obtain the right and bottom limits. Use the status bar on LM to get its block coordinate on both,
		Here is an example:<br>
		<img src="readme_files/Tutorial_SettingUpBorders.png"></li><br>
		
		<li>With the coordinates in hand we have, in the example:
			<ul>
				<li>Leftmost X position: <kbd>$000E</kbd>, rightmost: <kbd>$001E</kbd></li>
				<li>Topmost Y position: <kbd>$0005</kbd>, bottommost: <kbd>$000A</kbd></li>
			</ul>
		</li>
		
		<li>To convert block coordinates into pixel-coordinates, simply multiply the numbers by 16 ($10), an easier format is to put a formula in the tables and asar will reconize it and convert it for you
		upon assembling. Here is what it should be:
<table><tr><td><pre>;Top-left positions
	ScreenBoundsXPositions:
		dw $000E*16		;&gt;$00
	ScreenBoundsYPositions:
		dw $0005*16		;&gt;$00</pre></td></tr></table><br>
		
		To get the widths and heights, the formula for that is <kbd>(Block_BottomRightmost-Block_TopLeftmost)*16</kbd>, so it should be:
<table><tr><td><pre>	ScreenBoundsWidths:
		dw ($001E-$000E)*16		;&gt;$00
	ScreenBoundsHeights:
		dw ($000A-$0005)*16		;&gt;$00
</pre></td></tr></table>
		And you are done. If you want to add more bounded areas, do the same thing as above, but at a different XY position of your choice, once that is done, add a new entry in each table, makeing sure they match and not be
		associated to the wrong item. In this example of having a second area:<br>
		<img src="readme_files/Tutorial_SettingUpBorders2.png"><br>
		And the tables should be:
<table><tr><td><pre>;Top-left positions
	ScreenBoundsXPositions:
		dw $000E*16		;&gt;$00
		dw $002E*16		;&gt;$01
	ScreenBoundsYPositions:
		dw $0005*16		;&gt;$00
		dw $0005*16		;&gt;$01</pre></td></tr></table><br>
<table><tr><td><pre>	ScreenBoundsWidths:
		dw ($001E-$000E)*16		;&gt;$00
		dw ($003E-$002E)*16		;&gt;$01
	ScreenBoundsHeights:
		dw ($000A-$0005)*16		;&gt;$00
		dw ($000A-$0005)*16		;&gt;$01</pre></td></tr></table>
		</li>
		<li>And now you are done</li>
	</ol>
	<h4>Note using in a level</h2>
	<p>If the areas overlap, and the player is in that area, whatever last on the table list the player is in will take precedence and overrides any borders before it on the table, as the routine, like most codes uses a
	<a href="https://ersanio.gitbook.io/assembly-for-the-snes/deep-dives/techniques#looping">negative check loop</a> (a loop that an index starts with a specified number besides 0, and in that loop, the index decrements
	until it goes negative (X/Y = $FF, for example) and exits).</p>
