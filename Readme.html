<html>
	<head>
		<style>
			html {
			background-color: #000207;
			color: white;
			font-family: sans-serif;
			}
			
			table, th, td {
			border: 1px solid white;
			border-collapse: collapse;
			}
			
			span.NoLineBreak {
				white-space: nowrap;
			}
			
			abbr{cursor: help;}
			img.img-hor {
				-moz-transform: scaleX(-1);
				-o-transform: scaleX(-1);
				-webkit-transform: scaleX(-1);
				transform: scaleX(-1);
				filter: FlipH;
				-ms-filter: "FlipH";
			}
		</style>
	</head>
<body>
<center><h1>Custom scroll limits</h1></center>
<h2>Introduction</h2>
<p>This ASM package enables you to set custom boundaries of your level.</p>

<p>Also comes with a feature to have Megaman/Celeste/Zelda-styled scroll areas where the camera will not cross between areas unless you go to that area.</p>

<p>Normally, you would think this is redundant because there exist other codes that stops the screen scrolling at a certain XY position, say one
found in the <a href="https://www.smwcentral.net/?p=viewthread&t=62286">ASM library</a>, however this ASM package offers more flexibility, and that
you can have &ldquo;multiple scroll stops&rdquo; without duplicate code</p>
<h2>Note before use</h2>
<ul>
	<li>The patch (<kbd>ScrollLimitsPatch.asm</kbd>) obviously will hijack scrolling related codes (<kbd>$00F73C</kbd> (horizontal level limits for left and right borders), <kbd>$00F893</kbd>
	(horizontal and vertical limits for top and bottom borders)). If you wish to have other scrolling-related patches such as my <a href="https://www.smwcentral.net/?p=section&a=details&id=26861">&ldquo;Center scroll&rdquo; patch</a>
	or <a href="https://www.smwcentral.net/?p=section&a=details&id=17737">Vertical Camera Panning</a>. In these cases, you'll need to merge the ASM files (more specifically, not to use SMW's default scroll limits but
	use this custom scroll limits patch's RAM that controls the limits). This patch itself just modifies the limits, nothing more.</li>
	<li>SMW's horizontal scrolling is instant-- that it simply takes Mario's X position, take various calculations handled at <kbd>$00F73C</kbd> (which also handles the left and right limits), unlike vertical scrolling,
	which that is handled at <kbd>$00F88F</kbd>, horizontal scrolling <b>instantly</b> sets the screen X position within the level rather than gradually incrementing/decrementing it. So these situations should be avoided that causes
	layer 1 graphic glitches due to not giving it frames to load the columns of 16x16 tiles:
		<ul>
			<li>Teleporting the player, as in taking the player's X position (<kbd>$94</kbd>), add or subtract by some large number (greater than &plusmn;$0010) that results the player being &ldquo;teleported&rdquo; in long distances.</li>
			<li>Have horizontal scrolling disabled (<kbd>$1411</kbd> set to $00), then enable horizontal scrolling while the player is outside the static camera region. This will cause the camera to jump to be centered
			with the player</li>
		</ul>
	
	</li>
	<li>RAM address <kbd>$13F2</kbd> is no longer cleared by <kbd>$00F8A7</kbd>.</li>
	<li>Anytime you want to trigger a &ldquo;<abbr title="The effect you see in Megaman games, areas separated by scroll limits that the screen will not go past unless the player triggers something like opening a door or touching the edge of an area">flip screen</abbr>&rdquo;
	effect, I <b>highly</b> recommend setting <kbd>$1411</kbd> and/or <kbd>$1412</kbd> to zero (disable horizontal and/or vertical scrolling). Even though uberasm tool already
	STZs it, if you don't disable horizontal and/or scrolling and your code is executed, then runs <kbd>$00F70D</kbd> or <kbd>$00F75C</kbd>, before executing uberasm tool's gamemode 14, screen-jumping (screen changes position instantly
	and result graphical glitches) can still occur.</li>
	<li>Setting <kbd>$1411</kbd> and <kbd>$1412</kbd> only disables the default scrolling (the behavior of the screen to follow the player) as well as the scrolling limit not to go outside the level. Autoscroll generators have done this
	so that the player cannot move the screen as they wish.</li>
	<li>When the screen is at the bottommost of the level (with LM's &ldquo;Allow viewing full bottom row of tiles&rdquo; being checked in the &ldquo;Change Properties in Header&rdquo; dialog.), the screen's Y position is showing 1 pixel row
	<b>beyond</b> the bottom of the level (for example: with the level dimension setting (horizontal level mode) set to <kbd>08: Level Height=02A tiles, Max H-Screens=15</kbd>), and have the camera position at <kbd>Y=$01C0</kbd>, you can see
	last row of pixels at the bottom of the screen showing the top pixels of garbage/unloaded blocks. It seems that the screen display seems to be 1 pixel lower than the values presented in the SNES register $210E/RAM $1C/RAM $1464. The easy fix
	is to simply move the custom border 1 pixel up (in this example, the Y position of the screen should be <kbd>$01BF</kbd>).</li>
</ul>
<h2 id="WhatYouNeed">What you need</h2>
<ul>
	<li><a href="https://www.smwcentral.net/?p=section&a=details&id=13675">Sprite scroll fix</a>: SMW's system to check which scroll direction sprites should be able to spawn (<kbd>$55</kbd>/<kbd>$56</kbd>) is flawed, that it
	check which side the player is located relative to the &ldquo;static camera region&rdquo; (<kbd>$142A</kbd>), rather than the actual scrolling of the screen. This bug only happens if you &ldquo;manually&rdquo; scroll the screen,
	common method is by setting <kbd>$1411</kbd> to zero and incrementing/decrementing <kbd>$1462</kbd>, can cause sprites to spawn on the side of the screen that the screen is moving away from rather than towards, and failing to spawn.</li>
	<li><a href="https://www.smwcentral.net/?p=section&a=details&id=14978">Disable Screen Barrier via RAM</a>: Useful if you want such triggers that would trigger the flip-screen effect by touching the very edges of the screen, and also
	prevent potential deaths caused by being at those edges of the screen.</li>
	<li>
		ASM knowledge, if you're using other scrolling-related patches (like my previously mentioned &ldquo;center scroll&rdquo; patch), then there is a chance you'll have to modify them (and/or merge them if the hijacks overlap), especially if those patches have code that sets the scrolling limit itself:
		<ul>
			<li><a href="https://www.smwcentral.net/?p=section&a=details&id=20949">ASM workshop</a></li>
			<li><a href="https://www.smwcentral.net/?p=section&a=details&id=14268">Ersanio's ASM tutorial</a></li>
		</ul><br>
		
		Here is a hint: XY position top and left positions are <b>always</b> X/Y = <kbd>$0000</kbd>. The right and bottom limits are:
		<ul>
			<li>Horizontal levels (and any dimension settings): <kbd>LastScreenXPosition = (ValueIn_RAM_5E - 1) * 256</kbd>. The bottom position is stored in scratch RAM <kbd>$04</kbd> during around <kbd>$00F810</kbd>. Unlike <kbd>$13D7</kbd>, LM have a feature with an option to enable the screen
			to scroll down to show the last row of blocks at the very bottom of the level, on &ldquo;Change Properties in Header&rdquo;.</li>
			<li>Vertical levels: The last screen on the horizontal axis is <b>always</b> at X = <kbd>$0100</kbd> (since vertical level settings are always 2 screens wide). The bottom position is at <kbd>LastScreenYPosition = (ValueIn_RAM_5F - 1) * 256</kbd>.</li>
		</ul>
	</li>
</ul>
<h2>Interesting facts</h2>
<ul>
	<li>When horizontal and/or vertical scrolling are disabled (<kbd>$1411</kbd> and/or <kbd>$1412</kbd>), the boundaries (left or right for horizontal, top and bottom for vertical) are no longer running (it will not set the XY coordinate of
	the screen to place it back in bounds).</li>
</ul>
<h2>Installation</h2>
	<ol>
		<li>Defines</li>
		<ol>
			<li>Open <kbd>SMW-Scroll-limits/ScrollLimitsDefines/Defines.asm</kbd>, and make any necessary changes on it. There is a very high chance you'll need to do this if you have other ASM resources that uses freeram as well, as they
			tend to &ldquo;overlap&rdquo; with the default RAMs the patch provided here uses. And yes, even the required patches <a href="#WhatYouNeed">stated here</a> needs to have its freeram defines changed to avoid issues.</li>
		</ol>
		<li>Patches</li>
		<ol>
			<li>Before you patch <kbd>ScrollLimitsPatch.asm</kbd> or other patches related to scrolling, open <kbd>ScrollLimitsPatch.asm</kbd> AND the other patches (specifically if they hijack scrolling-related code) and see the
			<kbd>org $xxxxxx</kbd> would conflict. If they do, you'll need to merge them and potentially need to learn a little bit of ASM.<br><br>
			
			<kbd>ScrollLimitsPatch.asm</kbd> just modifies the behavior how scrolling limits work. If you say, install my &ldquo;Center Scroll&rdquo; patch, for example, edit the center scroll patch's scroll limits so that it first checks
			the RAM defined by <kbd>!Freeram_ScrollLimitsFlag</kbd>, and if it is nonzero, then it should do something similar how the patch provided here works (which means you'll need to learn about ASM).</li>
		</ol>
		<li>Uberasm tool (installs the flip screen effect)</li>
		<ol>
			<li>In <kbd>SMW-Scroll-limits/UberasmTool/</kbd>, place the files in their appropriate spots in uberasm tool's files. They are conveniently named.</li>
			<li>Run the tool</li>
		</ol>
	</ol>
<h2>How to use them in a level</h2>
	<p>With these installed (properly) you can now set your own borders. Keep these information in mind:</p>
	<ul>
		<li><font color="grey">Grey</font> means outside the level boundaries</li>
		<li><font color="blue">blue</font> means inside the level boundaries</li>
		<li><font color="cyan">cyan</font> means the game screen</li>
		<li><font color="#800000">red</font> means the boundaries specified by the RAM the patch uses</li>
		<li><font color="orange">orange</font> means the actual scrolling stopping position for the bottom and right borders</li>
	</ul>
	<p>Scroll stopping positions info</p>
	<ul>
		<li>Origin positions:<br>
		<img src="readme_files/LevelAndGameScreen.png"><br>
		Almost everything have their origin point on their top-left corner.</li>
		<li>How the right and bottom borders are placed, relative to the origin position of the scroll limits box:<br>
		<img src="readme_files/ScrollLimitsBox.png"></li>
		<li>Where the screen will stop at relative to the border:<br>
		<img src="readme_files/LeftAndTop.png"><br>
		Pretty obvious, but for bottom and right borders, they take the screen's origin position to limit instead of the right and bottom edge of the screen:<br>
		<img src="readme_files/RightAndBottom.png"><br>
		</li>
	</ul>
<h2>Data table format</h2>
	<ul>
		<li>
<table><tr><td><pre>main:
	;This prevents the layers from snapping upon entering the level after a fade-in
		LDA.b #ScreenBoundsXPositions : STA $00
		LDA.b #ScreenBoundsXPositions&gt;&gt;8 : STA $01
		LDA.b #ScreenBoundsXPositions&gt;&gt;16 : STA $02
		LDA.b #ScreenBoundsYPositions : STA $03
		LDA.b #ScreenBoundsYPositions&gt;&gt;8 : STA $04
		LDA.b #ScreenBoundsYPositions&gt;&gt;16 : STA $05
		LDA.b #ScreenBoundsWidths : STA $06
		LDA.b #ScreenBoundsWidths&gt;&gt;8 : STA $07
		LDA.b #ScreenBoundsWidths&gt;&gt;16 : STA $08
		LDA.b #ScreenBoundsHeights : STA $09
		LDA.b #ScreenBoundsHeights&gt;&gt;8 : STA $0A
		LDA.b #ScreenBoundsHeights&gt;&gt;16 : STA $0B
		LDA.b #(ScreenBoundsYPositions-ScreenBoundsXPositions)-2 : STA $0C : STZ $0D
		JSL LibraryScrollLimits_SetupBorders
		LDA #$03 : STA $0C
		JSL LibraryScrollLimits_ControlBorders
		RTL
;Scroll limit box attributes, each index is each screen area.
;Make sure the number of values all matches!
;
;Note: If the screen can be at the bottommost of the level and with &ldquo;Allow viewing full bottom row of tiles&rdquo;
;checked, it can show a row of pixels at the bottom of the screen of garbage/unloaded tiles. Therefore to avoid this, use
;these formulas instead (it is the same, but after all calculations, it is subtracted by 1):
;If the height is set to 0 (no room for moving the screen vertically)
; YPos = (LM_CoordinateOfTopLeft_TopOrLeftmost_Screen*16)-1
;If the height isn't 0:
; Width = ((LM_CoordinateOfTopLeft_BottomOrRightmost_Screen-LM_CoordinateOfTopLeft_TopOrLeftmost_Screen)*16)-1
;
;
;Easy formula to calculate where the screen should be at:
; LM_CoordinateOfTopLeft_TopOrLeftmost_Screen*16
; Where:
;  -LM_CoordinateOfTopLeft_TopOrLeftmost_Screen means the top left of the screen at the leftmost
;   position possible, in block-coordinates (not pixel), either X or Y position
;Top-left positions
	ScreenBoundsXPositions:
		dw $0000*16		;&gt;$00
		dw $0018*16		;&gt;$01
		dw $0028*16		;&gt;$02
		dw $0028*16		;&gt;$03
		dw $003C*16		;&gt;$04
		dw $004C*16		;&gt;$05
		dw $005C*16		;&gt;$06
		dw $005C*16		;&gt;$07
		dw $007C*16		;&gt;$08
		dw $009D*16		;&gt;$09
	ScreenBoundsYPositions:
		dw $0000*16		;&gt;$00
		dw $0015*16		;&gt;$01
		dw $000B*16		;&gt;$02
		dw ($001C*16)-1		;&gt;$03
		dw $0000*16		;&gt;$04
		dw $000C*16		;&gt;$05
		dw $000C*16		;&gt;$06
		dw $001A*16		;&gt;$07
		dw $0000*16		;&gt;$08
		dw $0000*16		;&gt;$09
;Widths and heights. Easy formula if you want positions for both the top-lefts and bottom-rights.
; WidthOrHeights = (LM_CoordinateOfTopLeft_BottomOrRightmost_Screen-LM_CoordinateOfTopLeft_TopOrLeftmost_Screen)*16
; Where:
;  -LM_CoordinateOfTopLeft_TopOrLeftmost_Screen: means the top left of the screen at the leftmost
;   position possible, in block-coordinates (not pixel), either X or Y position
;  -LM_CoordinateOfTopLeft_BottomOrRightmost_Screen: means the top-left of the screen at the rightmost
;   position possible, in block-coordinates (not pixel), either X or Y position
	ScreenBoundsWidths:
		dw ($0008-$0000)*16	;&gt;$00
		dw ($0018-$0018)*16	;&gt;$01
		dw ($0028-$0028)*16	;&gt;$02
		dw ($0046-$0028)*16	;&gt;$03
		dw ($003C-$003C)*16	;&gt;$04
		dw ($004C-$004C)*16	;&gt;$05
		dw ($006C-$005C)*16	;&gt;$06
		dw ($0063-$005C)*16	;&gt;$07
		dw ($008D-$007C)*16	;&gt;$08
		dw ($00AD-$009D)*16	;&gt;$09
	ScreenBoundsHeights:
		dw ($000C-$0000)*16	;&gt;$00
		dw ($0015-$0015)*16	;&gt;$01
		dw ($000B-$000B)*16	;&gt;$02
		dw ($001C-$001C)*16	;&gt;$03
		dw ($000E-$0000)*16	;&gt;$04
		dw ($000C-$000C)*16	;&gt;$05
		dw ($000C-$000C)*16	;&gt;$06
		dw ($001A-$001A)*16	;&gt;$07
		dw ($001B-$0000)*16	;&gt;$08
		dw ($001B-$0000)*16	;&gt;$09</pre></td></tr></table><br>
		The tables, labeled <kbd>ScreenBoundsXPositions</kbd>, <kbd>ScreenBoundsYPositions</kbd>, <kbd>ScreenBoundsWidths</kbd>, and <kbd>ScreenBoundsHeights</kbd>, is what we need to focus on.
		Keep in mind that each same nth item in the table are associated with each other, meaning that the first item in the tables are used together for zone 0, second item in tables for zone 1, and so on,
		they do not use other items within them (like zone 0 uses first item in <kbd>ScreenBoundsXPositions</kbd>, second item in <kbd>ScreenBoundsYPositions</kbd>, it doesn't work like that)</li>
	</ul>
	
<h3>Instructions to use in level</h3>
	<ol>
		<li>After creating a level, make LM display the &ldquo;Game View Screen&rdquo;, this is found in the <kbd>View</kbd> on the menu bar or pressing F3. Hold ALT+F3 to drag it around and place them
		at the top-left area where you want to place your top and leftmost limit, then hover your mouse on a block where that top-left area of the screen. Do the same thing again but place the game view
		screen at the bottom-rightmost area (while still using the top-left of the game view screen), to obtain the right and bottom limits. Use the status bar on LM to get its block coordinate on both,
		Here is an example:<br>
		<img src="readme_files/Tutorial_SettingUpBorders.png"></li><br>
		
		<li>With the coordinates in hand we have, in the example:
			<ul>
				<li>Leftmost X position: <kbd>$000E</kbd>, rightmost: <kbd>$001E</kbd></li>
				<li>Topmost Y position: <kbd>$0005</kbd>, bottommost: <kbd>$000A</kbd></li>
			</ul>
		</li>
		
		<li>To convert block coordinates into pixel-coordinates, simply multiply the numbers by 16 ($10), an easier format is to put a formula in the tables and asar will reconize it and convert it for you
		upon assembling. Here is what it should be:
<table><tr><td><pre>;Top-left positions
	ScreenBoundsXPositions:
		dw $000E*16		;&gt;$00
	ScreenBoundsYPositions:
		dw $0005*16		;&gt;$00</pre></td></tr></table><br>
		
		To get the widths and heights, the formula for that is <kbd>(Block_BottomRightmost-Block_TopLeftmost)*16</kbd>, so it should be:
<table><tr><td><pre>	ScreenBoundsWidths:
		dw ($001E-$000E)*16		;&gt;$00
	ScreenBoundsHeights:
		dw ($000A-$0005)*16		;&gt;$00
</pre></td></tr></table>
		And you are done. If you want to add more bounded areas, do the same thing as above, but at a different XY position of your choice, once that is done, add a new entry in each table, makeing sure they match and not be
		associated to the wrong item. In this example of having a second area:<br>
		<img src="readme_files/Tutorial_SettingUpBorders2.png"><br>
		And the tables should be:
<table><tr><td><pre>;Top-left positions
	ScreenBoundsXPositions:
		dw $000E*16		;&gt;$00
		dw $002E*16		;&gt;$01
	ScreenBoundsYPositions:
		dw $0005*16		;&gt;$00
		dw $0005*16		;&gt;$01</pre></td></tr></table><br>
<table><tr><td><pre>	ScreenBoundsWidths:
		dw ($001E-$000E)*16		;&gt;$00
		dw ($003E-$002E)*16		;&gt;$01
	ScreenBoundsHeights:
		dw ($000A-$0005)*16		;&gt;$00
		dw ($000A-$0005)*16		;&gt;$01</pre></td></tr></table>
		</li>
		<li>And now you are done</li>
	</ol>
	<h4>Note using in a level</h2>
	<ul>
		<li>If the areas overlap, and the player is in that area, whatever last on the table list the player is in will take precedence and overrides any borders before it on the table, as the routine, like most codes uses a
		<a href="https://ersanio.gitbook.io/assembly-for-the-snes/deep-dives/techniques#looping">negative check loop</a> (a loop that an index starts with a specified number besides 0, and in that loop, the index decrements
		until it goes negative (X/Y = $FF, for example) and exits).</li><br>
		
		<li>
			Layer 2 XY positioning may suddenly jump on the first frame after the level was loaded, if the player spawns at a position the screen would be outside the scroll borders. This is due to the stuff being executed in this order:
			<ol>
			<li>
				<kbd>$00f79d</kbd>: LM's hijack to use its own layer 2 scrolling code, this is executed once during a black screen (not every frame):
<table><tr><td><pre>;Note about what these RAMs are:
$1413 [1 byte]: Horizontal BG scrolling rate
$1414 [1 byte]: Vertical BG scrolling rate
$1417 [2 bytes]: Layer 2 Y offset, after processing its scrolling rate.
$1A or $1462 [2 bytes]: Layer 1 X pos (or &ldquo;screen position&rdquo; within the level)
$1C or $1464 [2 bytes]: Layer 1 Y pos (or &ldquo;screen position&rdquo; within the level)
$1E or $1466 [2 bytes]: Layer 2 X pos
$20 or $1468 [2 bytes]: Layer 2 Y pos</pre></td></tr></table><br>
<table><tr><td><pre>	;Note that the address may be different from yours, since they occupy freespace.
	;This is tested using LM v3.21.
	;00f79d jml $108350   ;\$1413 and $1414: determine what scrolling rate for horizontal and vertical
	;108350 lda $1413     ;|
	;108353 asl a         ;|\Both $1413 and $1414 are doubled since the values to jump are 16-bit addresses.
	;108354 tax           ;||
	;108355 xba           ;||
	;108356 tay           ;//
	;108357 lda $1a       ;&gt;Layer 1 X pos
	;108359 jmp ($837a,x) ;&gt;This jumps to one of the LSR below, which determines the rate of horizontal scrolling
	;10835C lsr a         ;\Take layer 1 X pos, divide by 2**n, and store that number into layer 2 X pos
	;10835D lsr a         ;|Layer2XPos = Layer1XPos / (2**n)
	;10835E lsr a         ;|
	;10835F lsr a         ;|
	;108360 lsr a         ;|
	;108361 lsr a         ;|
	;108362 sta $1e       ;/
	;108364 tyx           ;\Do the same thing but Y position, this time, with an offset in $1417.
	;108365 lda $1c       ;|Layer2YPos = Layer1YPos / (2**n) + ValueInRAM_1417
	;108367 jmp ($838a,x) ;|
	;10836a lsr a         ;|
	;10836b lsr a         ;|
	;10836c lsr a         ;|
	;10836d lsr a         ;|
	;10836e lsr a         ;|
	;10836f lsr a         ;|
	;108370 clc           ;|
	;108371 adc $1417     ;|
	;108374 sta $20       ;/
	;108376 jml $00f7c2   ;&gt;Return to SMW code
	;;[...]
	;10837a:
	;;These contain the word (16-bit) address to jump to one of the LSRs.
	;dw $8364             ;&gt;$10837a (Index $00); when $1413 == $00 (none)
	;dw $8362             ;&gt;$10837c (Index $02); when $1413 == $01 (constant)
	;dw $8361             ;&gt;$10837e (Index $04); when $1413 == $02 (variable)
	;;[...]
	;10838a:
	;;These contain the word (16-bit) address to jump to one of the LSRs, same as above but for $1414.
	;dw $8376             ;&gt;10838a (Index $00); when $1414 == $00 (none)
	;dw $8370             ;&gt;10838c (Index $02); when $1414 == $01 (constant)
	;dw $836F             ;&gt;10838e (Index $04); when $1414 == $02 (variable)
	;dw $836B             ;&gt;108390 (Index $06); when $1414 == $03 (slow)
	;dw $836E             ;&gt;108392 (Index $08); when $1414 == $04 (slow 2)
	;dw $836D             ;&gt;108394 (Index $0A); when $1414 == $05 (slow 3?)
	;dw $836C             ;&gt;108396 (Index $0C); when $1414 == $06 (slow 4?)
	;dw $836A             ;&gt;108398 (Index $0E); when $1414 == $07 (slow 5?)</pre></td></tr></table>
			</li><br>
			<li>Uberasm tool's level <kbd>load</kbd> code.</li><br>
			<li>A few frames later, executes SMW's scrolling code routine (both Mario moving the screen as well as the scrolling limits), such as <kbd>$00F893</kbd>.</li><br>
			</ol>
			Therefore, LM will set the layer 2 XY pos, using layer 1 XY pos that was BEFORE it was moved to be within bounds.
		</li>
	</ul>